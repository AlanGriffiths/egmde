/*
 * AUTOGENERATED - DO NOT EDIT
 *
 * This file is generated from gtk-primary-selection.xml
 * To regenerate, run the “refresh-wayland-wrapper” target.
 */

#include "gtk-primary-selection_wrapper.h"

#include <boost/throw_exception.hpp>
#include <boost/exception/diagnostic_information.hpp>

#include <wayland-server-core.h>

#include "mir/log.h"

namespace mir
{
namespace wayland
{
extern struct wl_interface const gtk_primary_selection_device_interface_data;
extern struct wl_interface const gtk_primary_selection_device_manager_interface_data;
extern struct wl_interface const gtk_primary_selection_offer_interface_data;
extern struct wl_interface const gtk_primary_selection_source_interface_data;
extern struct wl_interface const wl_seat_interface_data;
}
}

namespace mw = mir::wayland;

namespace
{
struct wl_interface const* all_null_types [] {
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr};
}

// GtkPrimarySelectionDeviceManager

mw::GtkPrimarySelectionDeviceManager* mw::GtkPrimarySelectionDeviceManager::from(struct wl_resource* resource)
{
    return static_cast<GtkPrimarySelectionDeviceManager*>(wl_resource_get_user_data(resource));
}

struct mw::GtkPrimarySelectionDeviceManager::Thunks
{
    static int const supported_version;

    static void create_source_thunk(struct wl_client* client, struct wl_resource* resource, uint32_t id)
    {
        auto me = static_cast<GtkPrimarySelectionDeviceManager*>(wl_resource_get_user_data(resource));
        wl_resource* id_resolved{
            wl_resource_create(client, &gtk_primary_selection_source_interface_data, wl_resource_get_version(resource), id)};
        if (id_resolved == nullptr)
        {
            wl_client_post_no_memory(client);
            BOOST_THROW_EXCEPTION((std::bad_alloc{}));
        }
        try
        {
            me->create_source(id_resolved);
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionDeviceManager::create_source()");
        }
    }

    static void get_device_thunk(struct wl_client* client, struct wl_resource* resource, uint32_t id, struct wl_resource* seat)
    {
        auto me = static_cast<GtkPrimarySelectionDeviceManager*>(wl_resource_get_user_data(resource));
        wl_resource* id_resolved{
            wl_resource_create(client, &gtk_primary_selection_device_interface_data, wl_resource_get_version(resource), id)};
        if (id_resolved == nullptr)
        {
            wl_client_post_no_memory(client);
            BOOST_THROW_EXCEPTION((std::bad_alloc{}));
        }
        try
        {
            me->get_device(id_resolved, seat);
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionDeviceManager::get_device()");
        }
    }

    static void destroy_thunk(struct wl_client* client, struct wl_resource* resource)
    {
        auto me = static_cast<GtkPrimarySelectionDeviceManager*>(wl_resource_get_user_data(resource));
        try
        {
            me->destroy();
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionDeviceManager::destroy()");
        }
    }

    static void resource_destroyed_thunk(wl_resource* resource)
    {
        delete static_cast<GtkPrimarySelectionDeviceManager*>(wl_resource_get_user_data(resource));
    }

    static void bind_thunk(struct wl_client* client, void* data, uint32_t version, uint32_t id)
    {
        auto me = static_cast<GtkPrimarySelectionDeviceManager::Global*>(data);
        auto resource = wl_resource_create(
            client,
            &gtk_primary_selection_device_manager_interface_data,
            std::min((int)version, Thunks::supported_version),
            id);
        if (resource == nullptr)
        {
            wl_client_post_no_memory(client);
            BOOST_THROW_EXCEPTION((std::bad_alloc{}));
        }
        try
        {
            me->bind(resource);
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionDeviceManager global bind");
        }
    }

    static struct wl_interface const* create_source_types[];
    static struct wl_interface const* get_device_types[];
    static struct wl_message const request_messages[];
    static void const* request_vtable[];
};

int const mw::GtkPrimarySelectionDeviceManager::Thunks::supported_version = 1;

mw::GtkPrimarySelectionDeviceManager::GtkPrimarySelectionDeviceManager(struct wl_resource* resource, Version<1>)
    : client{wl_resource_get_client(resource)},
      resource{resource}
{
    if (resource == nullptr)
    {
        BOOST_THROW_EXCEPTION((std::bad_alloc{}));
    }
    wl_resource_set_implementation(resource, Thunks::request_vtable, this, &Thunks::resource_destroyed_thunk);
}

bool mw::GtkPrimarySelectionDeviceManager::is_instance(wl_resource* resource)
{
    return wl_resource_instance_of(resource, &gtk_primary_selection_device_manager_interface_data, Thunks::request_vtable);
}

void mw::GtkPrimarySelectionDeviceManager::destroy_wayland_object() const
{
    wl_resource_destroy(resource);
}

mw::GtkPrimarySelectionDeviceManager::Global::Global(wl_display* display, Version<1>)
    : wayland::Global{
          wl_global_create(
              display,
              &gtk_primary_selection_device_manager_interface_data,
              Thunks::supported_version,
              this,
              &Thunks::bind_thunk)}
{}

auto mw::GtkPrimarySelectionDeviceManager::Global::interface_name() const -> char const*
{
    return GtkPrimarySelectionDeviceManager::interface_name;
}

struct wl_interface const* mw::GtkPrimarySelectionDeviceManager::Thunks::create_source_types[] {
    &gtk_primary_selection_source_interface_data};

struct wl_interface const* mw::GtkPrimarySelectionDeviceManager::Thunks::get_device_types[] {
    &gtk_primary_selection_device_interface_data,
    &wl_seat_interface_data};

struct wl_message const mw::GtkPrimarySelectionDeviceManager::Thunks::request_messages[] {
    {"create_source", "n", create_source_types},
    {"get_device", "no", get_device_types},
    {"destroy", "", all_null_types}};

void const* mw::GtkPrimarySelectionDeviceManager::Thunks::request_vtable[] {
    (void*)Thunks::create_source_thunk,
    (void*)Thunks::get_device_thunk,
    (void*)Thunks::destroy_thunk};

// GtkPrimarySelectionDevice

mw::GtkPrimarySelectionDevice* mw::GtkPrimarySelectionDevice::from(struct wl_resource* resource)
{
    return static_cast<GtkPrimarySelectionDevice*>(wl_resource_get_user_data(resource));
}

struct mw::GtkPrimarySelectionDevice::Thunks
{
    static int const supported_version;

    static void set_selection_thunk(struct wl_client* client, struct wl_resource* resource, struct wl_resource* source, uint32_t serial)
    {
        auto me = static_cast<GtkPrimarySelectionDevice*>(wl_resource_get_user_data(resource));
        std::experimental::optional<struct wl_resource*> source_resolved;
        if (source != nullptr)
        {
            source_resolved = {source};
        }
        try
        {
            me->set_selection(source_resolved, serial);
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionDevice::set_selection()");
        }
    }

    static void destroy_thunk(struct wl_client* client, struct wl_resource* resource)
    {
        auto me = static_cast<GtkPrimarySelectionDevice*>(wl_resource_get_user_data(resource));
        try
        {
            me->destroy();
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionDevice::destroy()");
        }
    }

    static void resource_destroyed_thunk(wl_resource* resource)
    {
        delete static_cast<GtkPrimarySelectionDevice*>(wl_resource_get_user_data(resource));
    }

    static struct wl_interface const* set_selection_types[];
    static struct wl_interface const* data_offer_types[];
    static struct wl_interface const* selection_types[];
    static struct wl_message const request_messages[];
    static struct wl_message const event_messages[];
    static void const* request_vtable[];
};

int const mw::GtkPrimarySelectionDevice::Thunks::supported_version = 1;

mw::GtkPrimarySelectionDevice::GtkPrimarySelectionDevice(struct wl_resource* resource, Version<1>)
    : client{wl_resource_get_client(resource)},
      resource{resource}
{
    if (resource == nullptr)
    {
        BOOST_THROW_EXCEPTION((std::bad_alloc{}));
    }
    wl_resource_set_implementation(resource, Thunks::request_vtable, this, &Thunks::resource_destroyed_thunk);
}

void mw::GtkPrimarySelectionDevice::send_data_offer_event(struct wl_resource* offer) const
{
    wl_resource_post_event(resource, Opcode::data_offer, offer);
}

void mw::GtkPrimarySelectionDevice::send_selection_event(std::experimental::optional<struct wl_resource*> const& id) const
{
    struct wl_resource* id_resolved = nullptr;
    if (id)
    {
        id_resolved = id.value();
    }
    wl_resource_post_event(resource, Opcode::selection, id_resolved);
}

bool mw::GtkPrimarySelectionDevice::is_instance(wl_resource* resource)
{
    return wl_resource_instance_of(resource, &gtk_primary_selection_device_interface_data, Thunks::request_vtable);
}

void mw::GtkPrimarySelectionDevice::destroy_wayland_object() const
{
    wl_resource_destroy(resource);
}

struct wl_interface const* mw::GtkPrimarySelectionDevice::Thunks::set_selection_types[] {
    &gtk_primary_selection_source_interface_data,
    nullptr};

struct wl_interface const* mw::GtkPrimarySelectionDevice::Thunks::data_offer_types[] {
    &gtk_primary_selection_offer_interface_data};

struct wl_interface const* mw::GtkPrimarySelectionDevice::Thunks::selection_types[] {
    &gtk_primary_selection_offer_interface_data};

struct wl_message const mw::GtkPrimarySelectionDevice::Thunks::request_messages[] {
    {"set_selection", "?ou", set_selection_types},
    {"destroy", "", all_null_types}};

struct wl_message const mw::GtkPrimarySelectionDevice::Thunks::event_messages[] {
    {"data_offer", "n", data_offer_types},
    {"selection", "?o", selection_types}};

void const* mw::GtkPrimarySelectionDevice::Thunks::request_vtable[] {
    (void*)Thunks::set_selection_thunk,
    (void*)Thunks::destroy_thunk};

// GtkPrimarySelectionOffer

mw::GtkPrimarySelectionOffer* mw::GtkPrimarySelectionOffer::from(struct wl_resource* resource)
{
    return static_cast<GtkPrimarySelectionOffer*>(wl_resource_get_user_data(resource));
}

struct mw::GtkPrimarySelectionOffer::Thunks
{
    static int const supported_version;

    static void receive_thunk(struct wl_client* client, struct wl_resource* resource, char const* mime_type, int32_t fd)
    {
        auto me = static_cast<GtkPrimarySelectionOffer*>(wl_resource_get_user_data(resource));
        mir::Fd fd_resolved{fd};
        try
        {
            me->receive(mime_type, fd_resolved);
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionOffer::receive()");
        }
    }

    static void destroy_thunk(struct wl_client* client, struct wl_resource* resource)
    {
        auto me = static_cast<GtkPrimarySelectionOffer*>(wl_resource_get_user_data(resource));
        try
        {
            me->destroy();
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionOffer::destroy()");
        }
    }

    static void resource_destroyed_thunk(wl_resource* resource)
    {
        delete static_cast<GtkPrimarySelectionOffer*>(wl_resource_get_user_data(resource));
    }

    static struct wl_message const request_messages[];
    static struct wl_message const event_messages[];
    static void const* request_vtable[];
};

int const mw::GtkPrimarySelectionOffer::Thunks::supported_version = 1;

mw::GtkPrimarySelectionOffer::GtkPrimarySelectionOffer(GtkPrimarySelectionDevice const& parent)
    : client{wl_resource_get_client(parent.resource)},
      resource{wl_resource_create(client, &gtk_primary_selection_offer_interface_data, wl_resource_get_version(parent.resource), 0)}
{
    if (resource == nullptr)
    {
        BOOST_THROW_EXCEPTION((std::bad_alloc{}));
    }
    wl_resource_set_implementation(resource, Thunks::request_vtable, this, &Thunks::resource_destroyed_thunk);
}

void mw::GtkPrimarySelectionOffer::send_offer_event(std::string const& mime_type) const
{
    const char* mime_type_resolved = mime_type.c_str();
    wl_resource_post_event(resource, Opcode::offer, mime_type_resolved);
}

bool mw::GtkPrimarySelectionOffer::is_instance(wl_resource* resource)
{
    return wl_resource_instance_of(resource, &gtk_primary_selection_offer_interface_data, Thunks::request_vtable);
}

void mw::GtkPrimarySelectionOffer::destroy_wayland_object() const
{
    wl_resource_destroy(resource);
}

struct wl_message const mw::GtkPrimarySelectionOffer::Thunks::request_messages[] {
    {"receive", "sh", all_null_types},
    {"destroy", "", all_null_types}};

struct wl_message const mw::GtkPrimarySelectionOffer::Thunks::event_messages[] {
    {"offer", "s", all_null_types}};

void const* mw::GtkPrimarySelectionOffer::Thunks::request_vtable[] {
    (void*)Thunks::receive_thunk,
    (void*)Thunks::destroy_thunk};

// GtkPrimarySelectionSource

mw::GtkPrimarySelectionSource* mw::GtkPrimarySelectionSource::from(struct wl_resource* resource)
{
    return static_cast<GtkPrimarySelectionSource*>(wl_resource_get_user_data(resource));
}

struct mw::GtkPrimarySelectionSource::Thunks
{
    static int const supported_version;

    static void offer_thunk(struct wl_client* client, struct wl_resource* resource, char const* mime_type)
    {
        auto me = static_cast<GtkPrimarySelectionSource*>(wl_resource_get_user_data(resource));
        try
        {
            me->offer(mime_type);
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionSource::offer()");
        }
    }

    static void destroy_thunk(struct wl_client* client, struct wl_resource* resource)
    {
        auto me = static_cast<GtkPrimarySelectionSource*>(wl_resource_get_user_data(resource));
        try
        {
            me->destroy();
        }
        catch(...)
        {
            internal_error_processing_request(client, "GtkPrimarySelectionSource::destroy()");
        }
    }

    static void resource_destroyed_thunk(wl_resource* resource)
    {
        delete static_cast<GtkPrimarySelectionSource*>(wl_resource_get_user_data(resource));
    }

    static struct wl_message const request_messages[];
    static struct wl_message const event_messages[];
    static void const* request_vtable[];
};

int const mw::GtkPrimarySelectionSource::Thunks::supported_version = 1;

mw::GtkPrimarySelectionSource::GtkPrimarySelectionSource(struct wl_resource* resource, Version<1>)
    : client{wl_resource_get_client(resource)},
      resource{resource}
{
    if (resource == nullptr)
    {
        BOOST_THROW_EXCEPTION((std::bad_alloc{}));
    }
    wl_resource_set_implementation(resource, Thunks::request_vtable, this, &Thunks::resource_destroyed_thunk);
}

void mw::GtkPrimarySelectionSource::send_send_event(std::string const& mime_type, mir::Fd fd) const
{
    const char* mime_type_resolved = mime_type.c_str();
    int32_t fd_resolved{fd};
    wl_resource_post_event(resource, Opcode::send, mime_type_resolved, fd_resolved);
}

void mw::GtkPrimarySelectionSource::send_cancelled_event() const
{
    wl_resource_post_event(resource, Opcode::cancelled);
}

bool mw::GtkPrimarySelectionSource::is_instance(wl_resource* resource)
{
    return wl_resource_instance_of(resource, &gtk_primary_selection_source_interface_data, Thunks::request_vtable);
}

void mw::GtkPrimarySelectionSource::destroy_wayland_object() const
{
    wl_resource_destroy(resource);
}

struct wl_message const mw::GtkPrimarySelectionSource::Thunks::request_messages[] {
    {"offer", "s", all_null_types},
    {"destroy", "", all_null_types}};

struct wl_message const mw::GtkPrimarySelectionSource::Thunks::event_messages[] {
    {"send", "sh", all_null_types},
    {"cancelled", "", all_null_types}};

void const* mw::GtkPrimarySelectionSource::Thunks::request_vtable[] {
    (void*)Thunks::offer_thunk,
    (void*)Thunks::destroy_thunk};

namespace mir
{
namespace wayland
{

struct wl_interface const gtk_primary_selection_device_manager_interface_data {
    mw::GtkPrimarySelectionDeviceManager::interface_name,
    mw::GtkPrimarySelectionDeviceManager::Thunks::supported_version,
    3, mw::GtkPrimarySelectionDeviceManager::Thunks::request_messages,
    0, nullptr};

struct wl_interface const gtk_primary_selection_device_interface_data {
    mw::GtkPrimarySelectionDevice::interface_name,
    mw::GtkPrimarySelectionDevice::Thunks::supported_version,
    2, mw::GtkPrimarySelectionDevice::Thunks::request_messages,
    2, mw::GtkPrimarySelectionDevice::Thunks::event_messages};

struct wl_interface const gtk_primary_selection_offer_interface_data {
    mw::GtkPrimarySelectionOffer::interface_name,
    mw::GtkPrimarySelectionOffer::Thunks::supported_version,
    2, mw::GtkPrimarySelectionOffer::Thunks::request_messages,
    1, mw::GtkPrimarySelectionOffer::Thunks::event_messages};

struct wl_interface const gtk_primary_selection_source_interface_data {
    mw::GtkPrimarySelectionSource::interface_name,
    mw::GtkPrimarySelectionSource::Thunks::supported_version,
    2, mw::GtkPrimarySelectionSource::Thunks::request_messages,
    2, mw::GtkPrimarySelectionSource::Thunks::event_messages};

}
}
